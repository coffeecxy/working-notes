# embeded asm


一般情况下,写C代码的时候,我们不会嵌入汇编,但是在写系统内核的时候,有些时候还是需要嵌入汇编的.

C代码会被gcc先编译成.s代码,然后才会被as编译成.o文件.所以就可以在c代码中嵌入汇编代码,这样被嵌入的这部分汇编代码在这个.c 文件被编译成.s的时候就不会被编译了,而是直接放在相应的位置.

嵌入汇编的语法为

    asm("汇编语句"
        :输出寄存器
        :输入寄存器
        :会被修改的寄存器
    )

输出寄存器就是这段汇编代码运行完成之后,哪些寄存器会用来存放输出的结果.输入寄存就是会存放输入值的寄存器.会被改变的寄存器表示这里面列出的寄存器在我们的汇编语句中会被改变


## 使用#define来写嵌入汇编的时候要注意的问题

在linux0.11的内核代码中,存在大量的内嵌汇编代码,比如

    #define outb_p(value,port) \
    __asm__ ("outb %%al,%%dx\n" \
    		"\tjmp 1f\n" \
    		"1:\tjmp 1f\n" \
    		"1:"::"a" (value),"d" (port))

上面的代码就是要完成向一个外设端口中写入一个值,就是完成控制外设端口的功能.

如果使用`#define`的话,那么会使用很多的续行符,也就是`\`,c中的续行付有一个很麻烦的语法要求就是后面不能有任何的的其他字符了,包括注释用的`//`和`/**/`



比如把上面的代码改为.

    #define outb_p(value,port) \
    __asm__ ("outb %%al,%%dx\n" \//调用outb来完成写端口的功能
    		"\tjmp 1f\n" \
    		"1:\tjmp 1f\n" \
    		"1:"::"a" (value),"d" (port))
就是加上了注释,编译的时候会出现下面的错误.

    include/asm/io.h:19:3: error: expected identifier or ‘(’ before string constant
    "\tjmp 1f\n" \
    ^

这个错误第一下还看不出来是什么意思,其实就是因为在续行符后面添加了注释,而这个又不会被认为是注释. 当然就会有错误了.

### 使用inline来代替#define
实际上,我们使用这种#define就是为了得到内联函数的功能,也就是#define后面的一堆代码原地展开. 为了满足开发的时候这个语法要求,在gcc中最先加入了inline关键字. 在一个函数前面加上inline关键字,其还是可以使用函数的语法,但是效果却是原地展开的,也就是生成的汇编代码中是没有`call`和`ret`这些语句的.

    inline void outb_p(value,port) {
    	__asm__ ("outb %%al,%%dx\n" //调用outb来完成写端口的功能
    		"\tjmp 1f\n"
    		"1:\tjmp 1f\n"
    		"1:"::"a" (value),"d" (port));
    }



