# gnu as常用的指令

这里列出的全部都是格式为`.xxx`的指令,这些指令不会产生机器码,它们是辅助汇编代码编写的.

## .global
列出这个文件要导出的符号.

    .global _start, begtext, begdata, begbss, endtext, enddata, endbss

这个命令会导致后面列出的符号在这文件被`as`后生成的目标文件(一般是可重定位的elf文件,后缀一般是.o)中在符号表中被列出来,这样`ld`程序就可以看到它们了.

如果只想要生成一个raw binary文件(就是只有机器码的二进制文件),那么在ld的时候就需要把.o文件中的符号表去掉.

## .text,.data,.bss

在`as`生成的`.o`文件中,所有的内容是分段存储的,下面是我使用`readelf`从一个`.o`文件中读到的信息.

    Section Headers:
      [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
      [ 0]                   NULL            00000000 000000 000000 00      0   0  0
      [ 1] .text             PROGBITS        00000000 000034 000200 00  AX  0   0  1
      [ 2] .rel.text         REL             00000000 000778 000090 08      6   1  4
      [ 3] .data             PROGBITS        00000000 000234 000000 00  WA  0   0  1
      [ 4] .bss              NOBITS          00000000 000234 000000 00  WA  0   0  1
      [ 5] .shstrtab         STRTAB          00000000 000234 000030 00      0   0  1
      [ 6] .symtab           SYMTAB          00000000 0003a4 0002a0 10      7  35  4
      [ 7] .strtab           STRTAB          00000000 000644 000134 00      0   0  1

可以看出,这个文件中一共有8个段,其中第0个段没有使用.
第1个是.text段,从34h开始,占用了200h的长度(实际上,这是一个bootsect.s编译得到的.o,我们让.text段的长度为512B的,也就是200h).
第2个段是.rel.text,是对.text在ld的时候需要的信息.
后面可以看到,.data和.bss段的长度为0,因为在编写这个文件的时候,没有向.data和.bss中写入任何东西.
后面三个就是一些表了,其也是提供给`ld`程序使用的.

在汇编代码中,`.text`表示后面的内容编译之后全部放到.text段中去,同样的.data和.bss也是类似的意思.

## .equ
`.equ`指令的功能和C中的`#define`类似.

    .equ SETUPLEN, 4
比如有了上面的定义,以后代码中国出现了SETUPLEN,就是4.


## .byte,.word,.long,.quad,.octa

表示在当前的段中,分配一块内存.内存的大小分别为1,2,4,8,16个字节.

    .text

    sectors:
	    .word 0

    msg1:
    	.byte 13,10
    	.ascii "Loading system ..."
    	.byte 13,10,13,10

比如上面的代码,就是在当前的段(.text)中,分配了一块长度为2B的内存,其被填入的值是0.因为sectors标号就在这个分配语句这儿,所以其就相当于这变量的名字.

下面的`msg1`也是类似的,其表示为"\r\nLoading system ...\r\n"这个字符串.

这个类似于C里面的全局变量的定义.

## .org

    .org new_loc,fill

.org指令实际上和上面的几个指令完成类似的事情.

在编译的时候,每个区(.text,.data,.bss)都会有一个计数器,每往这区中填入一些东西,这个区相应的计数器就会增长.
比如遇到了一个命令`mov %ax,%dx`,那么这命令对应的机器指令的二进制形式就会被填入这个区中,然后这个区的计数器就会增加相应的字节数.

上面的那5个指令本身不会被编译为机器指令,但是它们表示的数的二进制的形式会被加入区中,然后这个区的计数器会增加相应的值.

.org指令比这几个指令更快,其直接让这个区的计数器变成`new_loc`这个值,中间的空白使用fill指定的值来填满,如果没有指定fill,那么默认使用0. 这在写bootsect的时候特别有用,因为bootsect要求512字节的最后两个字节的值为0xaa55,而前面的代码和数据不会有很多,那么直接

    .org 510
    .word $0xaa55
就可以保证最后两个字节是这样的了.
而且这样也会导致.text段的长度为512字节.
