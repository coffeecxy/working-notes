# 使用iptables进行防火墙和nat的管理

## iptables介绍

linux中使用netfilter来进行对在linux主机上面流通的数据包进行过滤和处理的功能,nettfilter是内核的内建功能,对外linux提供了iptables这个命令来进行管理.

iptables使用基于chain的方式来对在系统中流通的网络包进行处理.这些chain被放在不同的table中,系统默认的给出了几个table,这些table中有些默认的chain.默认的table有filter,nat,mangle,每个table中包含几个chain,

下图是这些chain作用的时间

![iptables中的chain的作用时间](iptable.png)

注意其中没有给出mangle这个table中的chain的作用时间,因为这个table使用都是很少的.

这个图的核心思想是,在系统中流通的网络包,其不是一下子就到达了其想要去的地方了.linux为了实现一些特殊的功能,会在这些包流通的时候,对其协议头(一般是链路层,网络层,传输层)进行检查,设置对其中的一些字段进行修改.

图中的每一个矩形和菱形,相当于网络包在系统中流动的时候会遇到的`检查站(chain)`,在这些检查站中,`检查员(rule)`会排着队对每一个到来的包进行检查,如果发现这个包满足自己的条件,就会对这个包进行一些操作. 注意其中的

一般的,我们会使用的filter中的INPUT和OUTPUT比较多,因为这两个chain是管理是否让一个package进入系统和是否让一个package从系统发出去的.

nat这个table是用来管理网络地址转换的,如果系统中安装了虚拟机,或者是使用像docker一样的
程序来完成虚拟化功能,一般的,这些虚拟机都需要有网络连接可以使用. 那么使用在主机中使用NAT
就是最直接方便的办法了.

iptable一般就是控制三种包的流向.分别是途中的A,B,C表示的流向.

1. A表示最终会进入到linux系统的包.经过nat.prerouting的时候,这个包会被判断为要进入linux主机,然后filter.input不会将这个包给丢弃了,这样这个包就会进入到linux主机了.
1. B表示linux主机充当了路由器的功能,这个包会被forward到其他主机.
2. C表示从linux主机产生的包往外面传送需要经过的chain. filte.output可能会让这个包不能出去,nat.postrouting会导致这个包进行nat的转换.

## 查看当前的iptable


	iptables [-t table] -L

-t后面是要查看的table,默认情况下,使用的是filter这个table, -L是list的意思

	Chain INPUT (policy ACCEPT)
	target     prot opt source               destination

	Chain FORWARD (policy ACCEPT)
	target     prot opt source               destination
	DOCKER     all  --  anywhere             anywhere
	ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
	ACCEPT     all  --  anywhere             anywhere
	ACCEPT     all  --  anywhere             anywhere

	Chain OUTPUT (policy ACCEPT)
	target     prot opt source               destination

	Chain DOCKER (1 references)
	target     prot opt source               destination

上面是在的主机上面使用这个命令得到的结果.
对于进来的数据包,因为INPUT中没有任何的rule,所以使用其默认的policy,也就是ACCEPT,让其
通过,同样的,对于出去的数据包,也是让其通过. 对于FORWARD的包,也就是这个包并不是要进入
到当前的linux主机的,有一些相应的规则.

需要注意的是,在我的主机上面运行了docker daemon,所以后面还有一个DCKER chain.

### 使用iptables-save,iptables-restore

还可以使用iptabls-save来查看iptables,

    cxy@cxy-X9DAi:~/soft/clion-1.0$ sudo iptables-save
    # Generated by iptables-save v1.4.21 on Sat Apr 11 13:32:34 2015
    *mangle
    :PREROUTING ACCEPT [252924:246361857]
    :INPUT ACCEPT [252814:246304941]
    :FORWARD ACCEPT [28:3302]
    :OUTPUT ACCEPT [167440:15225315]
    :POSTROUTING ACCEPT [167804:15266869]
    COMMIT
    # Completed on Sat Apr 11 13:32:34 2015
    # Generated by iptables-save v1.4.21 on Sat Apr 11 13:32:34 2015
    *nat
    :PREROUTING ACCEPT [1509:317646]
    :INPUT ACCEPT [1493:310172]
    :OUTPUT ACCEPT [6034:382667]
    :POSTROUTING ACCEPT [6034:382667]
    :DOCKER - [0:0]
    -A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
    -A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
    -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
    COMMIT
    # Completed on Sat Apr 11 13:32:34 2015
    # Generated by iptables-save v1.4.21 on Sat Apr 11 13:32:34 2015
    *filter
    :INPUT ACCEPT [53437:44686502]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [41199:4084835]
    :DOCKER - [0:0]
    -A FORWARD -o docker0 -j DOCKER
    -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
    -A FORWARD -i docker0 ! -o docker0 -j ACCEPT
    -A FORWARD -i docker0 -o docker0 -j ACCEPT
    COMMIT
    # Completed on Sat Apr 11 13:32:34 2015


上面使用了itables-save命令来实现对一个table的dump操作,这个命令有点像mysql数据库的dump操作,其输出的内容可以被放到`iptables-restore`命令来恢复.

可以看到,以`#`开始的是注释,`*filter`表示下面的命令是针对filter这个table的.
以`:`开始的是定义一个chain,可以看出,一个定义了4个chain,`:INPUT ACCEPT [12596:13026127]`
表示INPUT这个chain的默认操作是ACCEPT,后面的数字表示这chain现在已经处理过的包的数目.

后面的四行用于向每个chain里面加入一个rule,这里向FORWARD chain里面加入了四条rule.这四条rule都是因为使用了`docker -d`产生的.



## 修改iptable

	iptables [-t table] [-AI 链名] [-io 网络接口] [-p 协议] [-s 来源IP/网段] [-d 目的IP/网段] -j [ACCEPT|DROP|REJECT|LOG]

上面为修改iptable的基本的语法.

* -t用来选择要操作的table,默认的是filter table.

* -A表示在chain中增加一条rule,增加的这条rule会变成最后一条rule,比如原来有1-4这4条rule,那么增加的rule会变成第5条.

* -I和-A类似,只是增加的rule会变成第一条.链名为INPUT,OUTPUT,FORWARD之类的.

* -i,-o指包进入和出去的网络接口,比如eth0,wlan0,也就是使用`ifconfig`命令得到的哪些接口的名字.

* -p 指定匹配的协议,如果一个包是指定的协议的,那么才会匹配这个rule,有tcp,udp,icmp,all.

* -s 指定这个包中的来源IP/网段; -d表示这个包中的目的IP/网段.如果在前面加上`!`,表示非的意思.
* 比如`! -s 192.168.100.0/24`表示不是来自于192.168.100.*这个网段的包.

* -j后面跟上的是对这个包的处理动作.


	iptables -A INPUT -i lo -j ACCEPT
表示只要是从lo进来的包,都接受. 因为没有指定-s,-d选项,而没有指定的选项就是any的意思.

	iptables -A INPUT -i eth0 -s 192.168.100.10 -j ACCEPT
	iptables -A INPUT -i eth0 -s 192.168.100.230 -j DROP

表示从对来自于一个IP的包拒绝,对来自于另外一个IP的包接受.

### 针对TCP,UDP的端口进行设置
对于TCP和UDP的包,在其协议字段中,有端口的设置. 所以防火墙对于这两种协议的端口也可以设置.

> 需要注意的是,并不是所有的传输层协议都是有端口的概念的,一个很典型的就是unix socket协议,其通过unix系统上的一个特殊的文件来标识唯一性,而不是通过端口来标识.

	[-p tcp,udp] [--sport 端口范围] [--dport 端口返回]

当使用这两个参数的时候,一定要同时设置-p参数,其要为tcp,udp中的一个.

	iptables -A INPUT  -p tcp --dport 21 -j DROP

要连接到这台主机的使用tcp协议,且为21号端口的包都DROP,这样默认配置的ssh就进不来了.

	iptables -A INPUT -p tcp -s 192.168.1.100.0/24 --sport 1024:65534 --dport ssh -j DROP

表示从192.168.1.100/24这个网段过来的,源端口是1024-65534,目的端口是ssh(22)的包都会被丢弃,这样这个网段
的主机就不能ssh登录了.

### 根据包的状态来对包进行管理

    [-m state] [--state 状态]

* -m指的是我们要加载的外部模块,主要的模块有
    * state: 状态模块
    * mac: MAC地址模块

* --state为包的状态
    * INVALID 这个包是无效的
    * ESTABLISHED 这个包是在已经连接成功的TCP上面跑的
    * NEW : 这个包是想要进行来
    * RELATED 这个包和主机发送的包是有关系的


我们经常会使用到的一个防火墙规则是

	iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
表示所有已经建立了连接的和相关的包都放进来.

	iptables -A INPUT -m state --state INVALID -j DROP
表示不合法的进来的包就扔掉.

对于MAC地址过滤,其使用的参数为

    -m mac --mac-source MAC地址
比如

    iptables -A INPUT -m mac --mac-source aa:bb:cc:dd:ee:ff -j DROP
那么所有从这指定的MAC地址过来的想要进入系统的包都会被扔掉.

