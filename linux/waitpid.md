# waitpid

在linux的系统调用中,`waitpid`是一个比较难理解的系统调用.其函数原型为.

    int sys_waitpid(pid_t pid,unsigned long * stat_addr, int options)

注意给出的是内核中的函数原型,其和用户程序中调用的`waitpid`是完全一样的.

---

`waitpid`完成的功能就是等待当前进程的`一个子进程或者是一组子进程`结束.

其中的`pid`参数表示当前进程的一个子进程或者是一组子进程.其指明子进程的方式和`kill`中的pid参数是类似的.

* pid>0,表示当前进程的一个子进程,其进程号就是pid.
* pid=0,表示一组当前进程的子进程,它们的进程组号和当前进程的进程组号是一样的.
* pid<-1,表示一组当前进程的子进程,它们的进程组号为`-pid`
* pid=-1,表示`当前进程的所有子进程`.

如果给出的返回状态的地址`stat_addr`不为空,那么返回的状态信息会被放在这个地址中.

如果被等待的子进程当前是处于已经退出的状态(ZOMBIE),那么这个函数马上返回,返回值为该子进程的进号.

如果指定的子进程并不存在,那么函数直接返回,返回值为ECHLD,表示`子进程不存在`.

当要等待的子进程正在运行,而没有指定WNOHANG,那么当前进程会被切换出去,在再次被切换回来的时候,如果当前进程的信号位图中没有SIGCHLD,也就是等待的进程并没有退出,那么会返回`EINTR`,表示被中断的系统调用.

当options中指定了WNOHANG,表示如果要等待的子进程是正在运行(RUNNING)的,那么当前进程也会直接返回. 返回值为0,表示没有等到任何进程结束.

如果等待的子进程处于STOPPED状态,那么就会去查看其他的子进程.最后当前进程可能会切换出去等待.

options的值可能包含WUNTRACED,表示如果要等待的子进程是停止(STOPPED)的,那么当前进程不会一直等待,而是直接返回. 此时返回的就这个处于停止状态的子进程的进程号.

---
对于一个处于ZOMBIE状态的进程,其自己占用的所有系统资源已经释放了,但是在内核中的task数组中它还占用着一个槽位.

其父进程要对这个进程调用waitpid,这样这样task数组中的这个槽位才会被清空,而且这个进程对应的task_struct才会被清除.

所有如果程序设计不好,就是父进程没有对自己的子进程调用waitpid操作,会导致系统中很多的进程处于ZOMBIE状态. 如果一个父进程因为特殊原因退出了,那么其子进程的父进程会变成init进程,init进程会定期的调用waitpid函数,这样这些处于zombie的进程就会被清除出内存了.






