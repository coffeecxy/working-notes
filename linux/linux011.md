# linux0.11


在linux中,我们经常会不区分任务和进程. 当然,在写应用程序的时候,是完全可以不区分任何和进程的.

但是在内核中,这两者其实是有区别的. 在内核中,每一个任务在gdt都有自己的描述符. gdt中具体的安排是:

第0个是Null,也就是全0,因为这个是intel规定了的.

第1个是内核的代码段描述符,第2个是内核的数据段描述符.

第3个没有使用(linus当时设计的时候没有考虑清楚)

第4个是任务0的tss描述符,第5个任务0的ldt描述符.

第6个是任务1的tss描述符,第7个任务1的ldt描述符.

.....

然后在linux内核中,
对于每个任务,内核中都有一个`task_struct`数据结构来表示.在`task_struct`中,有一个域为`pid`,表示这个任务的进程号. pid是内核在新建(fork)一个进程的时候分配动态的分配出来的.

所以说,对于linux 0.11中的每个运行实体,都有一个唯一的任务号和进程号,但是任务号是和x86架构十分相关的一个标号,也就是其对应中gdt表中的一个描述符. 在不是x86下的内核实现,其意义就不太大了. 但是进程号在任何架构下的内核实现都是有意义的.

而且**好像**在后面版本的linux中,在x86的实现下,也没有使用其提供的tss任务管理来实现进程的切换操作了,因为使用tss来进行进程的切换太消耗资源了.
但是表示进程的结构体还是使用的`task_struct`命名.

所以,从数据结构的命名上,我们都可以看出linux的一点历史,linus最开始实现linux的时候,就是想让它跑在x86的机子上.


## 每个模块实现的方式.
Linux上一个单内核的实现形式.单内核的意思是内核中的所有部分都是实现在一起的.

```c
mem_init(main_memory_start,memory_end); //内核进行所有的初始化工作
trap_init();
blk_dev_init();
chr_dev_init();
tty_init();
time_init();
sched_init(); //在kernel/sched.c中,对cpu进行管理.
// fs/buffer.c
buffer_init(buffer_memory_end);
hd_init();
floppy_init();
```

在其init/main.c中,有如上的`xxx_init`函数,这些函数实现在整个源代码的各个相应的文件夹中.
可以看出,内核的各个部分,内存管理,块设备的驱动,字符设备的驱动,进程管理,高速缓存管理,文件系统实现这些都分散在其他的内核源代码中去了.

linux源代码的命名是很规范的,每个部分都有一个init程序.
