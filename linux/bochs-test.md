# 测试bochs安装

BIOS启动完成自检之后,会找到一个有效的启动设备来启动位于其上的系统.这个地方就是我们可以设置BIOS的启动顺序来选择需要启动系统的设备.

BIOS会读取这个设备(硬盘,软盘)上的第一个扇区,也就是其MBR,MBR上面包含三个部分,第一个是446B的引导程序,然后是64B的分区表,然后是2B的特殊的word,为0xaa55.

446B的引导程序决定了怎么引导这个硬盘上面的操作系统,这也是现在比较强大boot loader会改变的地方.比如说GRUB,其安装的时候就会将这446B的内容重写,以便让其运行自己的逻辑.

我这儿要做的一个测试是在这512B中写入一个合法的代码,让系统启动的时候会打印出一条信息.

首先,这个代码肯定是只能使用汇编代码的写,因为其中的代码是系统启动之后运行的CPU运行的第一份代码,如果用高级语言来写的话,它们的运行时都还没有.

如下是这份汇编代码.
注意的是,我们使用的工具链是`as86,ld86`,而不是当前使用最多的来自gnu的`as,ld`.
as86使用的语法是和intel的汇编语法类似的.也和dos下使用的汇编语法类似.
这份代码来自`linux内核完全注释`这本书.


    .global begtext,begdata,begbss,endtext,enddata,endbss

    .text
    begtext: ;定义每个段的初始位置

    .data
    begdata:

    .bss
    begbss:

    .text
    BOOTSEG = 0x07c0

    entry start

    start:
    	jmpi go,BOOTSEG
    go:
    	mov ax,cs
    	mov ds,ax
    	mov es,ax
    	mov [msg1+17],ah
    	mov cx,#20 !
    	mov dx,#0x1004
    	mov bx,#0x000c
    	mov bp,#msg1
    	mov ax,#0x1301
    	int 0x10
    loop1:
    	jmp loop1
    msg1:
    	.ascii "Loading system ..."
    	.byte 13,10 ;回车和换行两个字符
    	.org 510
    	.word 0xaa55

    .text
    endtext:
    .data
    enddata:
    .bss
    endbss:

需要使用的编译链接命令为

    as86 -o boot.o boot.s
    ld86 -d  -o boot.sec boot.o

注意到ld86命令使用了-d选项,其会让生成的代码是一个纯的二进制文件,而不是某种特殊格式的可执行文件.
比如,如果ld86的时候不带-d选项,生成的文件是`Minix-386 impure executable not stripped`类型的,大小有740B.加上了`-d`选项,生成的文件类型为`x86 boot sector`,其大小是512B.

现解释一下上面的代码,开始的jmpi指令就是保证cpu去执行go处标识的指令. jmpi指令的解释在下面. 因为BIOS会将这512B的代码复制到内存的`7c00`处,假设go标识的指令位置在这512B的偏移为4,那么jmpi就是跳转到`07c04`处执行的意思.

后面的代码就是调用BIOS的中断例程来在启动的时候打印`Loding system ...`. 具体的实现原理在书上有详细的解释.




### jmpi指令以及x86中的实模式

jmpi指令是段间跳转指令.对于使用过arm汇编的都知道,arm中的跳转指令就十分直接了,就是说跳转到哪儿去执行就完了,根本就不需要什么段间跳转.

其实,这个是intel本身的一个*设计问题*,如果intel当初设计得当的话,根本就不会出现这种奇怪的指令.

[这篇博文](http://blog.csdn.net/zhl1224/article/details/5735747)中比较详细的介绍了当时的情况.

比如说

    BOOTSEG = 0x07c0
    jmpi    4, #BOOTSEG
其意思是要跳转到`0c704`这个位置去执行代码.

在8086中,数据总线和地址总线是复用的,一共有20根,内部的所以寄存器都是16位的,所以其有`1^20=1m`的地址寻址能力,每次读写的位宽是16位.

在后面的80286中,复用的引脚数为24根,但内部的寄存器还是16位位宽的. 此时其内存的寻址能力到了`2^24=16M`.

这个设计上的缺陷一值到了80386才恢复过来,386中的数据总线和地址总线是一样的了,都是32位.

因为这个设计缺陷,在中80286中有两种工作模式,为`实模式`和`保护模式`.

保护模式比较好理解,就是将完全的使用的使用cpu的寻址能力,让其可以访问到16M的内存空间.*一般的,我们是要让CPU工作在包含模式下,*因为这样才完全的使用了CPU的能力. *不幸的是,CPU复位之后,其默认是工作在实模式下的.*

实模式就是为了兼容8086而产生的操作模式,在这个模式下面,CPU能访问的内存空间是1M,也就是8086能访问到的内存空间.

8086使用的内存访问模式十分奇怪,为了访问一个地址,必须同时提供一个段基地址和一个段内的偏移.
而实际的地址需要通过`段基址+偏移`的方式得到.段基址和偏移都是16位的. 但是其又不是简单的相加得到,其需要将段基址先左移4位,然后再和偏移相加.最后得到的是一个`20`位的地址.

比如说上面的地址,就是0c700+0004=0c704这个地址.

8086会有这个奇怪的地址访问方式,是因为其内部是两个8085CPU组成的.

8085是一个8位的CPU,其有16根地址线,能访问64K的地址. 将两颗8085合起来,直观的做法是,内部寄存器变成16位的,地址线宽度变成32位的,但是当时的工艺有限,8086的外部引脚放不下32根地址线,而且当时也认为,程序根本不需要多达4G的内存访问能力. 所以intel给出了外部只提供20根地址总线的方案,但是现在两个8085都有16根地址线,怎么安排它们的地址线呢?
intel使用了分段的方式,将一个8085的地址作为段基地址,另外一个8085的地址作为段内偏移地址.那么一个直观的做法就是让第一个8085的地址线可以取所有的值,然后让第二个8085的地址线只有低4位才有值,这样第一个地址左移四位,再加上第二的值,就是20位的值了. 但是intel没有这样做,*他让第二个16位地址也可以是任意的值!*.

这就产生了一个很麻烦的事情,不同的段基址+段偏移可以得到相同的20位地址.

    0000:0014 = 00000+0014 = 00014
    0001:0004 = 00010+0004 = 00014

比如上面的两个地址组合,其就产生了相同的20位地址.
